#+TITLE: coldnew's emacs config
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+STARTUP: overview indent align
#+BABEL: :cache yes
#+OPTIONS: ^:nil

# Badge
[[http://www.gnu.org/licenses/gpl-3.0.txt][https://img.shields.io/badge/license-GPL_3-green.svg?dummy]]
[[https://travis-ci.org/coldnew/coldnew-spacemacs][https://travis-ci.org/coldnew/coldnew-spacemacs.svg?branch=master]]

* About

This is my another emacs config, which is a totally rewrite version
based on top of [[https://github.com/syl20bnr/spacemacs][spacemacs]] and [[https://github.com/coldnew/coldnew-emacs][coldnew-emacs]] with [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]]
in [[http://orgmode.org/][org-mode]] ,but use English to write this config instead.

Feal free to use it :).

** Install or testing this config

- First use git to download whole repo

  : git clone https://github.com/coldnew/coldnew-spacemacs.git

- Then use git submodule to download the spacemacs

  : git submodule init
  : git submodule update

- Befor trying starting emacs, you need to bootstrap with [[https://github.com/cask/cask][Cask]]

  : cask install

- Then use =make= command to generate init.el file

  : make init.el

- If you don not put this repo on =~/.emacs.d=, you need to use following
  command to start emacs

  : emacs -q -l ~/coldnew-spacemacs/init.el

** Packages need to install in system (Optional)

Some extra packages need to install in system manually. These packages
are =optional= but can make my spacemacs work more nicely.

- Mac OSX

  #+BEGIN_SRC sh
    brew install the_silver_searcher \
         fasd \
         mu --with-emacs --HEAD \
         doxymacs
  #+END_SRC


- Gentoo Linux

  #+BEGIN_SRC sh
    USE="emacs" emerge sys-apps/the_silver_searcher \
       app-shells/fasd \
       net-mail/mu \
       app-emacs/doxymacs
  #+END_SRC

* The early setup

There's some setups I need to put to the beging of emacs config. These
setup is derived from my original's init.el file.

** load prefer newer

#+BEGIN_SRC emacs-lisp
  ;; since emacs 24.4, new option `load-prefer-newer' has been
  ;; introduce, which make me never accidentally using outdated compiled files.
  (setq load-prefer-newer t)
#+END_SRC

** Change the user-emacs-directory

#+BEGIN_SRC emacs-lisp
  ;; We set `user-emacs-directory' here so we can use command-line
  ;; switch different emacs configuration like following:
  ;;
  ;;    emacs -q -l ~/coldnew-spacemacs/init.el
  (setq user-emacs-directory
        (file-name-directory (or load-file-name (buffer-file-name))))
#+END_SRC

* Package Management with Cask and Pallet

[[https://github.com/rdallasgray/pallet][Pallet]] is a wonderful little tool built on [[https://github.com/cask/cask][Cask]], a dependency
management tool for Emacs packages. Pallet adds automatic updating of
the =Caskfile= when packages are installed and deleted.

** Installing Cask

Just run this command in your terminal of choice:

#+BEGIN_SRC sh :tangle no
  $ curl -fsSkL https://raw.github.com/cask/cask/master/go | python
#+END_SRC

then add =~/.cask/bin= to your =PATH= so that you can use =cask=.

** Creating a Caskfile

For now, we just need a minimal =Cask= to get Pallet set up. Mine
looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
  (source gnu)
  (source melpa)

  (depends-on "evil")
  (depends-on "f")
  (depends-on "s")
  (depends-on "dash")
  (depends-on "pallet")
  (depends-on "req-package")
#+END_SRC

Then run the following command in your =.emacs.d= directory to set up
[[https://github.com/rdallasgray/pallet][Pallet]].

#+BEGIN_SRC sh :tangle no
  cask install
#+END_SRC

** Initialize Cask

Finally, we add the following lines to our init file:

#+BEGIN_SRC emacs-lisp
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
#+END_SRC

** Initialize Pallet

Since we already install pallet via cask, we just need to use
following code to initialize pallet.

#+BEGIN_SRC emacs-lisp
  (require 'pallet)
  (pallet-mode t)
#+END_SRC

* Dependency Management with req-package

[[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
management tool. The documentation for =use-package= is immensely
helpful for figuring out how to describe package dependencies and
settings. =req-package= adds the =:require= keyword which allows us to
define dependencies between related packages.

** Initialize req-package

With the preceding process complete, we just need to add the following
line to our init file to begin using =req-package=:

#+BEGIN_SRC emacs-lisp
  (require 'req-package)
#+END_SRC

** Start loading packages in right order

To start loading packages in right order, we need to added following
in the last of emacs config.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package-finish)
#+END_SRC

You can take a look at [[*End%20of%20configuration][End of configuration]] section.

* Load Path

The variable =load-path= lists all the directories where Emacs should
look for Elisp files.

Though I use =Cask= as package management in my emacs, some local
packages like my own theme or others can't fetch by elpa need to add
to load-path, this will help emacs find them.

Following are my method to add directories to load-path ~recursively~,
this function also create directory to prevent directory not exist.

If you don't have any local elisp and all packages is mantain by cask
or elpa or spacemacs, you can skip following code.

#+BEGIN_SRC emacs-lisp
  ;; Add directories to emacs's `load-path' recursively.
  ;; if path does not exist, create directory.
  (let* ((lisp-dir '("local-lisp/" "theme/")))
    (dolist (lisp-path lisp-dir)
      (when (not (file-exists-p lisp-path))
        (make-directory (concat user-emacs-directory lisp-path) t))
      (let* ((load-dir (concat user-emacs-directory lisp-path))
             (default-directory load-dir))
        (setq load-path
              (append
               (let ((load-path (copy-sequence load-path)))
                 (append
                  (copy-sequence (normal-top-level-add-to-load-path '(".")))
                  (normal-top-level-add-subdirs-to-load-path)))
               load-path)))))
#+END_SRC
* Spacemacs

[[https://github.com/syl20bnr/spacemacs][Spacemacs]] is an emacs starterkit focus on [[https://gitorious.org/evil/pages/Home][Evil]], which emulate vim
keymap on Emacs.

I make my emacs on top of spacemacs since I also use vim keymap.

In my config file, the original =~/.spacemacs= file has move to
=spacemacs.el= under user-emacs-directory folder, I also advice spacemacs funtion
to prevent orphan packages deleted by spacemacs.

After all spacemacs init done, switch back to =*scratch*= buffer.

** Load basic spacemacs configuration file

The original spacemacs will load =~/.spacemacs= as user configuration
file, I move this file to =~/.emacs.d/spacemacs.el=.

#+BEGIN_SRC emacs-lisp
  (load (concat user-emacs-directory "spacemacs.el"))
#+END_SRC

** Setup spacemacs configuration layers

spacemacs has many configuration layers, which can take as a
predefined keybinding/syntax highlight mode.

*** git

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/git][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers
               '(git :variables
                     git-gutter-use-fringe t
                     ))
#+END_SRC

*** company-mode

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/company-mode][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers 'company-mode)
#+END_SRC

*** c-c++

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/c-c%2B%2B][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers 'c-c++)
#+END_SRC

*** clojure

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/clojure][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers 'clojure)
#+END_SRC

*** html

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/html][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers 'html)
#+END_SRC

*** javascript

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/javascript][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers 'javascript)
#+END_SRC

*** markdown

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/markdown][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers 'markdown)
#+END_SRC

*** php

You can find doc [[https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/php][here]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'dotspacemacs-configuration-layers 'php)
#+END_SRC

** Overwrite spacemacs function to let it not remove my packages

#+BEGIN_SRC emacs-lisp
  ;; Make spacemacs not remove my orphan packages.
  (defadvice configuration-layer/delete-orphan-packages (around null-func activate)
    "Overwrite the spacemacs's `configuration-layer/delete-orphan-packages'
    to make it not remove any orphan packages.")
#+END_SRC

** Load spacemacs

#+BEGIN_SRC emacs-lisp
  ;; Make a fake entry point for spacemacs, also modify the
  ;; `user-emacs-directory' temporary to mislead spacemacs real emacs
  ;; directory.
  (let* ((spacemacs-dir
          (directory-file-name (concat user-emacs-directory "spacemacs")))
         (spacemacs-init
          (concat (file-name-as-directory spacemacs-dir) "init.el"))
         (user-emacs-directory (file-name-directory spacemacs-init)))

    ;; Initial spacemacs, our emacs run on top of it
    (load spacemacs-init))

  ;; Disable global highlight by default (which is set by spacemacs.)
  (global-hl-line-mode -1)

  ;; After spacemacs loading finished, switch back to `*scratch*' buffer
  (switch-to-buffer "*scratch*")
#+END_SRC

** HACKS

https://github.com/syl20bnr/spacemacs/issues/606

#+BEGIN_SRC emacs-lisp
(add-hook 'server-done-hook 'kill-buffer)
#+END_SRC

* Basic setup

Most setup I want to use is done by [[https://github.com/syl20bnr/spacemacs][spacemacs]], but I still keep some
basic setup here, some are not set or just keep for backward compability.

** Startup emacs server

#+BEGIN_SRC emacs-lisp
  ;; Only start server mode if I'm not root
  (unless (string-equal "root" (getenv "USER"))
    (require 'server)
    (unless (server-running-p) (server-start)))
#+END_SRC

** Under Mac OSX use Command key as ALT

Under Mac OSX, I always bind =Caps lock= as Control key, and make the
=Command= key as =ALT= key like I done in Linux.

The =Option= key will be setup as =Super=.

#+BEGIN_SRC emacs-lisp
  (setq mac-option-modifier 'super)
  (setq mac-command-modifier 'meta)
#+END_SRC

** Don't ask me when close emacs with process is running

#+BEGIN_SRC emacs-lisp
  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (flet ((process-list ())) ad-do-it))
#+END_SRC

** Don't ask me when kill process buffer

#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

* Languages and Encodings

Since current Emacs default run on UTF-8, it's no need to setup the
encoding.

For language, though Traditional Chinese is my mothertone, I still
prefer use =en_US= to display time info.

#+BEGIN_SRC emacs-lisp
  (setq system-time-locale "en_US" )
#+END_SRC

* Packages

Most of emacs packages do not need many configs or just provide
commands/functions to use, I put them here.

** 4clojure

[[https://github.com/losingkeys/4clojure.el][4clojure.el]] let you open and evaluate [[http://www.4clojure.com/][4clojure]] questions.

#+BEGIN_SRC emacs-lisp
  (req-package 4clojure)
#+END_SRC

** ascii

[[http://www.emacswiki.org/emacs/AsciiMode][Ascii]] provides a way to display ASCII code on a window, that is,
display in another window an ASCII table highlighting the current
character code.

#+BEGIN_SRC emacs-lisp
  (req-package ascii
    :init
    (progn
      ;; ascii-toggle
      (defun ascii-toggle ()
        "Toggle ascii-mode."
        (interactive)
        (if (not (ascii-off)) (ascii-on)))

      ;; alias ascii to ascii-toggle
      (defalias 'ascii 'ascii-toggle)))
#+END_SRC

** ascii-art-to-unicode

Convert simple ASCII art drawings (and org-tables) to beautiful Unicode.

#+BEGIN_SRC emacs-lisp
  (req-package ascii-art-to-unicode)
#+END_SRC

** iedit

[[https://github.com/victorhge/iedit][iedit]] let you edit multiple regions in the same way simultaneously.

#+BEGIN_SRC emacs-lisp
  (req-package iedit)
#+END_SRC

** pangu-spacing

[[https://github.com/coldnew/pangu-spacing][pangu-spcing]] is an minor-mode to auto add =space= between Chinese and
English characters. Note that these white-space characters are not
really added to the contents, it just like to do so.

#+BEGIN_SRC emacs-lisp
  (req-package pangu-spacing
    :init
    (progn
      ;; Always insert `real' space in org-mode.
      (add-hook 'org-mode-hook
                '(lambda ()
                   (set (make-local-variable 'pangu-spacing-real-insert-separtor) t)))))
#+END_SRC

** lusty-explorer

[[https://github.com/sjbach/lusty-emacs][lusty-explorer]] s a fast and responsive way to manage files and
buffers. It includes both a filesystem explorer and a buffer switcher
through a common interface.

#+BEGIN_SRC emacs-lisp
  (req-package lusty-explorer
    :init
    (progn
      ;; use lusty-explorer method to do completion
      (eval-after-load "helm-mode"
        '(progn
           (add-to-list 'helm-completing-read-handlers-alist '(lusty-file-explorer . nil))
           (add-to-list 'helm-completing-read-handlers-alist '(lusty-buffer-explorer . nil)))))
    :config
    (progn
      (add-hook 'lusty-setup-hook
                '(lambda ()
                   (define-key lusty-mode-map (kbd "RET") 'lusty-select-current-name)))))
#+END_SRC

** sx

[[https://github.com/vermiculus/sx.el/][SX]] is a full featured Stack Exchange mode for GNU Emacs 24+. Using the
official API, it provides a versatile experience for the Stack
Exchange network within Emacs itself.

#+BEGIN_SRC emacs-lisp
  (req-package sx :require sx-load)
#+END_SRC

** hungry-delete

[[https://github.com/nflath/hungry-delete][hungry-delete]] borrows hungry deletion from =cc-mode=, which will
causes deletion to delete all whitespace in the direction you are deleting.

#+BEGIN_SRC emacs-lisp
  (req-package hungry-delete
    :init (global-hungry-delete-mode))
#+END_SRC

** rainbow-mode

[[https://julien.danjou.info/projects/emacs-packages][rainbow-mode]] s a minor mode for Emacs which displays strings
representing colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-mode)
#+END_SRC

** doxymacs

#+BEGIN_SRC emacs-lisp
  (req-package doxymacs
    :config
    (add-hook 'prog-mode-hook '(lambda () (doxymacs-mode))))
#+END_SRC

** deft

[[http://jblevins.org/projects/deft/][deft]]

#+BEGIN_SRC emacs-lisp
  (req-package deft
    :config
    (progn
      ;; default extension set to .org
      (setq deft-extension "org")

      ;; setup an minor-mode to quickly kill all deft buffers
      (define-minor-mode deft-note-mode "Deft notes" nil " Deft-Notes" nil)
      (setq deft-text-mode 'deft-note-mode)

      ;; My notes set to ~/Copy/org
      (setq deft-directory "~/Copy/org/")

      ;; Use filename as title
      (setq deft-use-filename-as-title t)

      ;; Do not make deft automatically save file
      (setq deft-auto-save-interval 0)

      ;; Quickly kill deft buffers
      (defun kill-all-deft-notes ()
        (interactive)
        (save-excursion
          (let ((count 0))
            (dolist (buffer (buffer-list))
              (set-buffer buffer)
              (when (not (eq nil deft-note-mode))
                (setq count (1+ count))
                (kill-buffer buffer))))))

      ;; Enable/Disable defts
      (defun deft-or-close ()
        (interactive)
        (if (or (eq major-mode 'deft-mode) (not (eq nil deft-note-mode)))
            (progn (kill-all-deft-notes) (kill-buffer "*Deft*"))
          (deft)))))
#+END_SRC

** async

#+BEGIN_SRC emacs-lisp
  (req-package async
    :config
    (progn
      ;; If I'm edit my init.org, async generate init.el when save.
      (defun tangle-init ()
        "If the current buffer is 'init.org' the code-blocks are tangled."
        (when (equal (buffer-file-name)
                     (expand-file-name (concat user-emacs-directory "init.org")))
          (async-start
           `(lambda ()
              ,(async-inject-variables "user-emacs-directory")
              (require 'ob-tangle)
              (setq org-confirm-babel-evaluate nil)
              (org-babel-load-file (concat user-emacs-directory "init.org")))
           'ignore)))
      (add-hook 'after-save-hook 'tangle-init)
      ))
#+END_SRC


** password-generator

[[https://github.com/zargener/emacs-password-genarator][password-generator]] provides simple functions to create passwords and
insert them inside buffer immediately.

#+BEGIN_SRC emacs-lisp
  (req-package password-generator)
#+END_SRC

* Interactive Commands

In emacs, we can use =M-x= to execute interactive commands, I
implement some of them to make my emacs more easy to use.

** Buffers

*** Kill all buffers except *scratch* buffer

Sometimes I just want to kill all buffers, this command will kill all
of them and make =*scratch*= buffer alone.

#+BEGIN_SRC emacs-lisp
  (defun nuke-all-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapcar (lambda (x) (kill-buffer x)) (buffer-list))
    (delete-other-windows))
#+END_SRC

*** Make emacs can always save buffers (even if file is not modified)

The default command *save-buffer* will not really save file when it
untouched, use this command can let me force save file even if file is
not modified.

#+BEGIN_SRC emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))
#+END_SRC

*** Abort minibuffer recursive edit

#+BEGIN_SRC emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))
#+END_SRC

*** Make buffer untabify

#+BEGIN_SRC emacs-lisp
  (defun untabify-buffer ()
    (interactive)
    (save-excursion
      (untabify (point-min) (point-max))))
#+END_SRC

*** Indent whole buffer

#+BEGIN_SRC emacs-lisp
  (defun indent-whole-buffer ()
    "Indent whole buffer."
    (interactive)
    (save-excursion
      (indent-region (point-min) (point-max))))
#+END_SRC

*** Remove buffers trailing whitespace and untabify

#+BEGIN_SRC emacs-lisp
  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (save-excursion
      (delete-trailing-whitespace)
      (indent-region (point-min) (point-max))
      (untabify (point-min) (point-max))))
#+END_SRC

*** Replace the preceding sexp with its value

#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
#+END_SRC

** Edit (Insert/Remove)

*** Insert U200B char

=<U200B>= character is a =zero width space character= which is nice to
use under org-mode.

For more info, please see: [[https://lists.gnu.org/archive/html/emacs-orgmode/2012-09/msg00155.html][suggestion for org-emphasis-regexp-components: *U*nited *N*ations]]

#+BEGIN_SRC emacs-lisp
  (defun insert-U200B-char ()
    "Insert <U200B> char, this character is nice use in org-mode."
    (interactive)
    (insert "\ufeff"))
#+END_SRC

*** Insert empty line after current line

#+BEGIN_SRC emacs-lisp
  (defun insert-empty-line ()
    "Insert an empty line after current line and position cursor on newline."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1))
#+END_SRC

*** Delete word

#+BEGIN_SRC emacs-lisp
  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-region (point) (progn (forward-word arg) (point))))
#+END_SRC

*** Backward delete word

#+BEGIN_SRC emacs-lisp
  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))
#+END_SRC

*** Set mark or expand region

#+BEGIN_SRC emacs-lisp
  (defun rectangle-mark-mode/expand-region ()
    "toggle between set-mark-command or cua-rectangle-mark"
    (interactive)
    (if (not mark-active)
       (call-interactively 'rectangle-mark-mode)
      (call-interactively 'er/expand-region)))
#+END_SRC

*** Indent region/buffer and cleanup

#+BEGIN_SRC emacs-lisp
  (defun indent-region-or-buffer-and-cleanup ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (cl-flet ((format-fn (BEG END) (indent-region BEG END) (untabify BEG END)))
      (save-excursion
        (if (region-active-p)
            (progn
              (delete-trailing-whitespace (region-beginning) (region-end))
              (format-fn (region-beginning) (region-end))
              (message "Indented selected region and clear whitespace and untabify."))
          (progn
            (delete-trailing-whitespace)
            (format-fn (point-min) (point-max))
            (message "Indented whole buffer and clear whitespace and untabify."))))))
#+END_SRC

** File Handle

*** Reopen file as root

#+BEGIN_SRC emacs-lisp
  (defun file-reopen-as-root ()
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))
#+END_SRC

** Debug

*** Eval emacs buffer until error

A really nice command help me to find error on elisp buffer.

#+BEGIN_SRC emacs-lisp
  (defun eval-buffer-until-error ()
    "Evaluate emacs buffer until error occured."
    (interactive)
    (goto-char (point-min))
    (while t (eval (read (current-buffer)))))
#+END_SRC

* Theme

I always use dark theme for coding, [[https://github.com/kuanyui/moe-theme.el][moe-theme]] is a good start point,
it's bright and has good default faces for most modes. It also has
dark and light versions, which is convenient.

However, I always want to customize everything on my own, so I rebuild
another emacs theme called =coldnew-theme-night= and
=coldnew-theme-day= which are based on [[https://github.com/kuanyui/moe-theme.el][moe-theme]], you can find them at
[[file:theme/coldnew-theme.el]].

Before use emacs's =load-theme= function, I advise it to it fully
unload previous theme before loading a new one.

#+BEGIN_SRC emacs-lisp
  ;; Make `load-theme' fully unload previous theme before loading a new
  ;; one.
  (defadvice load-theme
      (before theme-dont-propagate activate)
    (mapc #'disable-theme custom-enabled-themes))

  ;; use coldnew-theme-night by default
  (req-package coldnew-theme
    :require (powerline powerline-evil)
    :init (coldnew-theme-night))
#+END_SRC

* Minibuffers

#+BEGIN_SRC emacs-lisp
  (req-package minibuffer
    :config
    (progn

      ;; Make cursor in minibufer use bar shape
      (add-hook 'minibuffer-setup-hook '(lambda () (setq cursor-type 'bar)))

      (define-key minibuffer-local-map (kbd "C-w") 'backward-kill-word)
      (define-key minibuffer-local-map (kbd "M-p") 'previous-history-element)
      (define-key minibuffer-local-map (kbd "M-n") 'next-history-element)
      (define-key minibuffer-local-map (kbd "C-g") 'minibuffer-keyboard-quit)

      (defun coldnew/minibuffer-switch-dir (path) (kill-line 0) (insert path))

      ;; switch to tmp dir
      (define-key minibuffer-local-map (kbd "M-t") '(lambda()
                                                      (interactive)
                                                      (let ((dir (if (eq system-type 'darwin)
                                                                     "~/ramdisk/" "/tmp/")))
                                                        (coldnew/minibuffer-switch-dir dir))))
      ;; switch to home dir
      (define-key minibuffer-local-map (kbd "M-h") '(lambda()
                                                      (interactive)
                                                      (coldnew/minibuffer-switch-dir "~/")))
      ))
#+END_SRC

* Editors

Why emacs config has an editor section, doesn't means emacs is not an
editor ? Yes, Emacs is an OS :)

I put some editor/IDE relative functions and packages here.

** Setup tab width

#+BEGIN_SRC emacs-lisp
  (setq tab-width 8)
  (setq indent-tabs-mode nil)
#+END_SRC

** Line Numbers

In most case, I'll make line numers display globally by =linum=.

#+BEGIN_SRC emacs-lisp
  (req-package linum :init (global-linum-mode 1))
#+END_SRC

Disable line number in some mode, for example, since =org-mode= can
has many lines, it's not recommand to enable linum-mode.

I use =linum-off= to disable some mode.

#+BEGIN_SRC emacs-lisp
  (req-package linum-off
    :config
    (progn
      (setq linum-disabled-mode-list
            '(eshell-mode shell-mode term-mode erc-mode compilation-mode
                          woman-mode w3m-mode calendar-mode org-mode
                          ))))
#+END_SRC

** Keeping files in sync

By default, Emacs will not update the contents of open buffers when a
file changes on disk. This is inconvenient when switching branches in
Git - as youâ€™d risk editing stale buffers.

This problem can be solved

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query '(".*")) ;; disable revert query
#+END_SRC

** Colorfy delimters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is a "rainbow parentheses"-like mode which
highlights delimiters such as parentheses, brackets or braces
according to their depth. Each successive level is highlighted in a
different color. This makes it easy to spot matching delimiters,
orient yourself in the code, and tell which statements are at a given
depth.

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Highlight numbers

[[https://github.com/Fanael/highlight-numbers][highlight-numbers]]

#+BEGIN_SRC emacs-lisp
  (req-package highlight-numbers
    :init
    ;; json-mode has it's own highlight numbers method
    (add-hook 'prog-mode-hook '(lambda()
                                 (if (not (derived-mode-p 'json-mode))
                                     (highlight-numbers-mode)))))
#+END_SRC

** Highlight escape charset

https://github.com/dgutov/highlight-escape-sequences

#+BEGIN_SRC emacs-lisp
  (req-package highlight-escape-sequences
    :config
    (progn
      ;; Make face the same as builtin face
      (put 'font-lock-regexp-grouping-backslash 'face-alias 'font-lock-builtin-face)

      ;; Add extra modes
      (add-to-list 'hes-simple-modes 'c-mode)
      (add-to-list 'hes-simple-modes 'c++-mode)

      ;; Enable globally
      (hes-mode 1)))
#+END_SRC

** Highlight FIXME, TODO

#+begin_src emacs-lisp
  (defun font-lock-comment-annotations ()
    "Highlight a bunch of well known comment annotations.
  This functions should be added to the hooks of major modes for programming."
    (font-lock-add-keywords
     nil
     '(("\\<\\(FIX\\(ME\\)?\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)
       ("\\<\\(NOTE\\):" 1 'org-level-2 t)
       ("\\<\\(TODO\\):" 1 'org-todo t)
       ("\\<\\(DONE\\):" 1 'org-done t))
     ))

  (add-hook 'prog-mode-hook 'font-lock-comment-annotations)
#+end_src

** Highlight indentation


TODO: only dupport python
#+BEGIN_SRC emacs-lisp
  (req-package highlight-indentation)
#+END_SRC

** Blocking syntax highlight

FIXME: buggy, can't really use
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package rainbow-blocks
    :init (global-rainbow-blocks-mode t))
#+END_SRC

** Takes care of trailing whitespaces (removal, highlighting)

https://github.com/glasserc/ethan-wspace

#+BEGIN_SRC emacs-lisp
  (req-package ethan-wspace
    :config
    (progn
      ;; Turn off `mode-require-final-newline' since ethan-wspace
      ;; supersedes `require-final-newline'.
      (setq mode-require-final-newline nil)

      ;; Enable ethan-wspace globally
      (global-ethan-wspace-mode 1)

      ;; Prevent etha-wspace touch my TAB on makefile mode
      (add-hook 'makefile-mode-hook
                '(lambda()
                   (setq ethan-wspace-errors (remove 'tabs ethan-wspace-errors))))

      ;; Ignore no trailing newline error
      (setq-default ethan-wspace-errors (remove 'no-nl-eof ethan-wspace-errors))))
#+END_SRC

** Add support for editorconfig

[[http://editorconfig.org/][EditorConfig]] helps developers define and maintain consistent coding
styles between different editors and IDEs. The EditorConfig project
consists of a file format for defining coding styles and a collection
of text editor plugins that enable editors to read the file format and
adhere to defined styles. EditorConfig files are easily readable and
they work nicely with version control systems.

#+BEGIN_SRC emacs-lisp
  (req-package editorconfig)
#+END_SRC

** Vim Emulation

#+BEGIN_SRC emacs-lisp
  (req-package evil
    :require (undo-tree)
    :ensure evil
    :init (evil-mode t)
    :config
    (progn
      ;; Bind all emacs-state key to insert state
      (setcdr evil-insert-state-map nil)
      (define-key evil-insert-state-map
        (read-kbd-macro evil-toggle-key) 'evil-emacs-state)

      ;; Make sure `ESC' in insert-state will call `evil-normal-state'
      (define-key evil-insert-state-map [escape] 'evil-normal-state)

      ;; Make all emacs-state buffer become to insert-state
      (dolist (m evil-emacs-state-modes)
        (add-to-list 'evil-insert-state-modes m))
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (req-package evil-terminal-cursor-changer)
#+END_SRC

** En/Decrypt files by [[http://emacswiki.org/emacs/EasyPG][EasyPG]]

#+BEGIN_SRC emacs-lisp
  (req-package epa-file
    :init (epa-file-enable)
    :config
    (progn
      ;; Control whether or not to pop up the key selection dialog.
      (setq epa-file-select-keys 0)
      ;; Cache passphrase for symmetric encryption.
      (setq epa-file-cache-passphrase-for-symmetric-encryption t)))
#+END_SRC

** Create *scratch* automatically

#+BEGIN_SRC emacs-lisp
  ;; Create *scratch* automatically
  (run-with-idle-timer 1 t
                       '(lambda ()
                          (unless (get-buffer "*scratch*")
                            (with-current-buffer (get-buffer-create "*scratch*")
                              (lisp-interaction-mode)))))
#+END_SRC

** Project management with projectile

#+BEGIN_SRC emacs-lisp
  (req-package projectile
    :interpreter ("projectile" . projectil-mode))
#+END_SRC

** Completion with Company mode

[[http://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidates.

#+BEGIN_SRC emacs-lisp
  (req-package company
    :init (global-company-mode 1)
    :config (setq company-idle-delay nil))
#+END_SRC

*** Completion C/C++ headers

#+BEGIN_SRC emacs-lisp
  (req-package company-c-headers
    :require company
    :init (add-to-list 'company-backends 'company-c-headers))
#+END_SRC

*** Add quickhelp in company-mode

#+BEGIN_SRC emacs-lisp
  (req-package company-quickhelp
    :require company
    :init (company-quickhelp-mode 1))
#+END_SRC

*** Key Bindings

#+TBLNAME: company-active-keys
| Key   | Command                    | description                          |
|-------+----------------------------+--------------------------------------|
| C-g   | company-abort              | abort company completion             |
| C-n   | company-select-next        | select next completion               |
| C-p   | company-select-previous    | select previous completion           |
| TAB   | company-complete-selection | Use TAB to select current completion |
| <tab> | company-complete-selection | Use TAB to select current completion |

#+BEGIN_SRC emacs-lisp :noweb yes
  (add-hook 'company-mode-hook '(lambda()
            <<define-keys(map="company-active-map", keys=company-active-keys)>> ))
#+END_SRC

** Snippet handle by yasnippet

#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :init (yas-global-mode 1)
    :mode ("emacs.+/snippets/" . snippet-mode)
    :config
    (progn
      (setq yas/prompt-functions '(yas-dropdown-prompt
                                   yas-completing-prompt
                                   yas-ido-prompt))

      (setq yas/snippet-dirs (concat user-emacs-directory "snippets"))))
#+END_SRC

*** Implement org-mode's easy-template like function

I really like org-mode's =easy-template= function, so I implement one
called =major-mode-expand= which will let you use easy-template like
function in any major-mode.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'yasnippet
    '(progn
       (defadvice yas-expand (around major-mode-expand activate)
         "Try to complete a structure template before point like org-mode does.
    This looks for strings like \"<e\" on an otherwise empty line and
    expands them.
    Before use this function, you must setup `major-mode-name'-expand-alist variable.

    Take emacs-lisp-mode as example, if you wand to use <r to expand your snippet `require'
    in yasnippet, you muse setup the emacs-lisp-mode-expand-alist variable.

     (setq emacs-lisp-expand-alist '((\"r\" . \"require\")))"
         (let* ((l (buffer-substring (point-at-bol) (point)))
                (expand-symbol (intern (concat (symbol-name major-mode) "-expand-alist")))
                (expand-alist (if (boundp expand-symbol) (symbol-value expand-symbol) nil))
                a)
           (when (and (looking-at "[ \t]*$")
                      (string-match "^[ \t]*<\\([a-zA-Z]+\\)$" l)
                      (setq a (assoc (match-string 1 l) expand-alist)))
             (backward-delete-char (1+ (length (car-safe a))))
             (if (symbolp (cdr-safe a))
                 (funcall (cdr-safe a))
               (insert (cdr-safe a)))
             t)
           ad-do-it))
       ))
#+END_SRC

Take emacs-lisp-mode as example, if I want to use =<r= and press =TAB=
then yasnippet will expand the command, just add following code:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq emacs-lisp-mode-expand-alist '(("r" . "require")))
#+END_SRC

For c-mode, just do the same but change the relative
*major-mode-expand-alist* like following

#+BEGIN_SRC emacs-lisp :tangle no
  (setq c-mode-expand-alist '(("i" . "include")))
#+END_SRC

** Helm

#+BEGIN_SRC emacs-lisp
  (req-package helm
    :require helm-config
    :init (helm-mode 1)
    :config
    (progn
      (bind-key "TAB" 'helm-execute-persistent-action helm-map)
      (bind-key "<tab>" 'helm-execute-persistent-action helm-map)
      ))
#+END_SRC

TODO: take from https://github.com/edvorg/emacs-configs/blob/master/init.d/init-helm.el
#+BEGIN_SRC emacs-lisp
  ;; helm google

  (req-package helm-google :commands helm-google)

  ;; helm proc

  (req-package helm-proc
    :require helm)

  ;; helm company

  (req-package helm-company
    :require company
    :commands helm-company
    :config (progn (define-key company-mode-map (kbd "C-:") 'helm-company)
                   (define-key company-active-map (kbd "C-:") 'helm-company)))

  ;; helm helm commands

  (req-package helm-helm-commands
    :require helm)

  ;; helm swoop

  (req-package helm-swoop
    :require
    helm
    :config
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch))

  ;; helm desc binds

  (req-package helm-descbinds :require helm)

  ;; helm open github

  (req-package helm-open-github
    :require helm
    :commands (helm-open-github-from-commit
               helm-open-github-from-file
               helm-open-github-from-issues
               helm-open-github-from-pull-requests)
    :bind (("C-c o f" . helm-open-github-from-file)
           ("C-c o c" . helm-open-github-from-commit)
           ("C-c o i" . helm-open-github-from-issues)
           ("C-c o p" . helm-open-github-from-pull-requests)))

  ;; helm package

  (req-package helm-package
    :require
    helm)

  ;; helm flymake

  (req-package helm-flymake
    :require
    (helm flymake))

  ;; helm make

  (req-package helm-make
    :require
    (helm makefile-runner)
    :config
    (global-set-key (kbd "s-B")
                    (lambda () (interactive) (helm-make (makefile-runner--find-makefile)))))

  ;; helm wgrep

  (req-package wgrep-helm
    :require
    (helm wgrep grep))

  ;; helm github stars

  (req-package helm-github-stars
    :require helm
    :config (setq helm-github-stars-username (getenv "USER")))

(req-package helm-ag :require helm)
#+END_SRC

* GDB

#+BEGIN_SRC emacs-lisp
  (req-package gdb-mi
    :require cc-mode
    :config
    (progn (setq gdb-many-windows t)
           (setq gdb-show-main t)))
#+END_SRC

* Terminal Emulator

** Eshell

eshell is not really a system shell, it's written in pure lisp. What I
like is it fully integrated with emacs.

*** Support for multi-eshell instance

#+BEGIN_SRC emacs-lisp
  (req-package multi-eshell
    :require eshell
    :config
    (progn
      (setq multi-eshell-shell-function '(eshell))
      (setq multi-eshell-name "*eshell*")))
#+END_SRC

*** Add autojump command

[[http://www.emacswiki.org/emacs/EshellAutojump][Eshell Autojump]] is an [[https://github.com/joelthelion/autojump][autojump]] like command written in pure elisp,
which add a =j= command to let you jump to folder you has been access.

#+BEGIN_SRC emacs-lisp
  (req-package eshell-autojump :require eshell)
#+END_SRC

* Window Management

** Maximized window after emac start

#+BEGIN_SRC emacs-lisp
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+END_SRC

** winner-mode

#+BEGIN_SRC emacs-lisp
  (req-package winner
    :config
    (progn
      ;; I use my own keymap for winner-mode
      (setq winner-dont-bind-my-keys t)
      ;; Start winner-mode globally
      (winner-mode t)))
#+END_SRC

* Programming Languages

** Android

#+BEGIN_SRC emacs-lisp
  (req-package android-mode
    :init (setq android-mode-sdk-dir (getenv "ANDROID_HOME")))
#+END_SRC

** Bash

#+BEGIN_SRC emacs-lisp
  (req-package flymake-shell
    :require (flymake shell)
    :config (add-hook 'sh-set-shell-hook 'flymake-shell-load))
#+END_SRC

** Batch

#+BEGIN_SRC emacs-lisp
  (req-package batch-mode :mode "\\.bat\\'")
#+END_SRC

** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (req-package lisp-mode
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.el$" . emacs-lisp-mode))
      (add-to-list 'auto-mode-alist '("Cask" . emacs-lisp-mode))
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (req-package eldoc
    :init
    (add-hook 'emacs-lisp-mode-hook
              '(lambda ()
                 ;; enable eldoc
                 (turn-on-eldoc-mode)
                 ;; fix for paredit if exist
                 (eval-after-load 'paredit
                   '(progn
                      (eldoc-add-command 'paredit-backward-delete
                                         'paredit-close-round))))))
#+END_SRC

*** On-the-fly evaluation/substitution of emacs lisp code

[[https://github.com/Fuco1/litable][litable]] keeps a list of pure functions as a safeguard for unwanted
evaluations. A function must first be accepted into this list (using
M-x litable-accept-as-pure) before it can be evaluated on-the-fly. You
should take care of what function you accept as pure to avoid any
unfortunate accidents. Also, note that the pure functions list
persists across sessions.

#+BEGIN_SRC emacs-lisp
  (req-package litable :init (litable-mode))
#+END_SRC

*** Highlight defined symbols

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package hl-defined
    :config
    (add-hook 'emacs-lisp-mode-hook 'hdefd-highlight-mode)
    (add-hook 'lisp-interaction-mode-hook 'hdefd-highlight-mode))
#+END_SRC

*** Highlight functions or macros belone to cl.el

#+BEGIN_SRC emacs-lisp
  (req-package highlight-cl
    :init
    (add-hook 'emacs-lisp-mode-hook
              '(lambda ()
                 (highlight-cl-add-font-lock-keywords))))
#+END_SRC

*** Remove *.elc when save

#+BEGIN_SRC emacs-lisp
  (defun remove-elc-on-save ()
    "If you're saving an elisp file, likely the .elc is no longer valid."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              (lambda ()
                (if (file-exists-p (concat buffer-file-name "c"))
                    (delete-file (concat buffer-file-name "c"))))))

  (add-hook 'emacs-lisp-mode-hook 'remove-elc-on-save)
#+END_SRC

** Org

#+BEGIN_SRC emacs-lisp
  (req-package org
    :require (org-crypt org-mac-link org-magit)
    :mode (("\\.org\\'" . org-mode)
           ("\\.org_archive\\'" . org-mode))
  :config
  (progn
    ;; fontify source code
    (setq org-src-fontify-natively t)
    ;; Use current window when switch to source block
    (setq org-src-window-setup 'current-window)
    ;; Disable prompting to evaluate babel blocks
    (setq org-confirm-babel-evaluate nil)
    ))
#+END_SRC

*** Extend org-mode's easy templates

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
      (add-to-list 'org-structure-template-alist
                   '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
      (add-to-list 'org-structure-template-alist
                   '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))
      (add-to-list 'org-structure-template-alist
                   '("p" "#+BEGIN_SRC plantuml :file uml.png \n?\n#+END_SRC"))
      ))
#+END_SRC

*** Extend babel support languages

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (C . t)
          (ditaa . t)
          (dot . t)
          (js . t)
          (latex . t)
          (perl . t)
          (python . t)
          (ruby . t)
          (sh . t)
          (plantuml . t)
          (clojure . t)
          ))))
#+END_SRC

*** Key Bindings

#+TBLNAME: org-mode-keys
| Key   | Command         | description |
|-------+-----------------+-------------|
| C-c b | org-metaleft    |             |
| C-c f | org-metaright   |             |
| C-c p | org-metaup      |             |
| C-c n | org-metadown    |             |
| C-c i | org-insert-link |             |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
  (add-hook 'org-mode-hook '(lambda()
            <<define-keys(map="org-mode-map", keys=org-mode-keys)>> ))
#+END_SRC

** SSH Config

#+BEGIN_SRC emacs-lisp
  (req-package ssh-config-mode
    :mode (("\\.ssh/config\\'"  . ssh-config-mode)
           ("sshd?_config\\'"   . ssh-config-mode)
           ("known_hosts\\'"    . ssh-known-hosts-mode)
           ("authorized_keys2?\\'" . ssh-authorized-keys-mode))
    :init (add-hook 'ssh-config-mode-hook 'turn-on-font-lock))
#+END_SRC

** CMake

#+BEGIN_SRC emacs-lisp
  (req-package cmake-font-lock
    :require (cmake-mode)
    :init (add-hook 'cmake-mode-hook 'cmake-font-lock-activate))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (req-package rust-mode)
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp
  (req-package go-mode
    :mode "\\.go$"
    :config
    (progn
      ;; Use gofmt to format code before save
      (add-hook 'before-save-hook 'gofmt-before-save)))
#+END_SRC

** C/C++

#+BEGIN_SRC emacs-lisp
  (req-package cc-mode
    :mode
    (("\\.h\\'" . c-mode)
     ("\\.c\\'" . c-mode)
     ("\\.hpp\\'" . c++-mode)
     ("\\.cpp\\'" . c++-mode))
    :config
    (progn
      ;; use regexp to check if it's C++ header
      (add-to-list 'magic-mode-alist
                   `(,(lambda ()
                        (and (string= (file-name-extension (or (buffer-file-name) "")) "h")
                             (or (re-search-forward "#include <\\w+>"
                                                    magic-mode-regexp-match-limit t)
                                 (re-search-forward "\\W\\(class\\|template\\namespace\\)\\W"
                                                    magic-mode-regexp-match-limit t)
                                 (re-search-forward "std::"
                                                    magic-mode-regexp-match-limit t))))
                     . c++-mode))
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (req-package clang-format
    :commands clang-format-region)
#+END_SRC




*** Highlight a few dangerous types in C/C++

[[http://www.emacswiki.org/emacs/CWarnMode][cwarn-mode]] is a minor mode that ca highlight a few dangerous types in C/C++.

By default it highlights:

- Semicolons right after conditions and loops (e.g. ~if (x == y);~)
- Assignments in tests (e.g. ~if (x = y) {~)
- Functions with reference parameters (e.g. ~void funct(string &p) {~)

#+BEGIN_SRC emacs-lisp
  (req-package cwarn
    :init (add-hook 'c-mode-common-hook '(lambda () (cwarn-mode 1))))
#+END_SRC

*** Add eldoc support for C/C++

#+BEGIN_SRC emacs-lisp
  (req-package c-eldoc
    :config
    (progn
      (add-hook 'c-mode-common-hook
                '(lambda ()
                   (setq c-eldoc-includes "`pkg-config gtk+-3.0 --cflags --libs` -I./ -I../")
                   (c-turn-on-eldoc-mode)))))
#+END_SRC

*** Use dummy-h-mode to help detect header's major mode

[[https://github.com/yascentur/dummy-h-mode-el][dummy-h-mode]] is an major-mode to help switch major mode to
c/c++/objc-mode on .h file.

#+BEGIN_SRC emacs-lisp
  (req-package dummy-h-mode
    :require cc-mode
    :mode "\\.h$"
    :config
    (progn
      (add-hook 'dummy-h-mode-hook
                (lambda ()
                  (setq dummy-h-mode-default-major-mode 'c-mode)))
      (add-hook 'dummy-h-mode-hook
                (lambda ()
                  (setq dummy-h-mode-search-limit 60000)))))
#+END_SRC

*** Syntax check and code-completion with CMake project

[[https://github.com/redguardtoo/cpputils-cmake][cpputils-cmake]] is a nice tool for cmake project.

#+BEGIN_SRC emacs-lisp
  (req-package cpputils-cmake
    :require (flycheck flycheck)
    :config
    (progn
      (add-hook 'c-mode-common-hook
                (lambda () (when (derived-mode-p 'c-mode 'c++-mode) (cppcm-reload-all))))))
#+END_SRC

*** C language coding style

**** Use Linux coding style by default

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-hook '(lambda () (c-set-style "linux")))
#+END_SRC

*** C++ language coding style

**** Use my C++ coding style

#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook
            '(lambda ()

               ;; Use stroustrup style
               (c-set-style "stroustrup")

               ;; Setting indentation lvel
               (setq c-basic-offset 4)

               ;; Make TAB equivilent to 4 spaces
               (setq tab-width 4)

               ;; Use spaces to indent instead of tabs.
               (setq indent-tabs-mode nil)

               ;; Indent the continuation by 2
               (setq c-continued-statement-offset 2)

               ;; Brackets should be at same indentation level as the statements they open
               ;; for example:
               ;;                 if (0)        becomes        if (0)
               ;;                     {                        {
               ;;                        ;                         ;
               ;;                     }                        }
               (c-set-offset 'substatement-open '0)

               ;; make open-braces after a case
               (c-set-offset 'case-label '+)
               ))
#+END_SRC

*** Extra highlight keywords for C/C++

stdint.h

#+BEGIN_SRC emacs-lisp
  (dolist (m '(c-mode c++-mode))
    (font-lock-add-keywords
     m
     '(("\\<\\(int8_t\\|int16_t\\|int32_t\\|int64_t\\|uint8_t\\|uint16_t\\|uint32_t\\|uint64_t\\)\\>" . font-lock-keyword-face))))
#+END_SRC

** Graphviz

#+BEGIN_SRC emacs-lisp
  (req-package graphviz-dot-mode
    :init (defalias 'dot-mode 'graphviz-dot-mode))
#+END_SRC

** Clojure/Clojurescript

#+BEGIN_SRC emacs-lisp
  (req-package clojure-mode
    :mode "\\.\\(clj\\|boot\\|cljs\\|cljs.hl\\)\\'")
#+END_SRC

** GLSL

#+BEGIN_SRC emacs-lisp
  (req-package glsl-mode
    :mode (("\\.vs\\'" . glsl-mode)
           ("\\.fs\\'" . glsl-mode)
           ("\\.gs\\'" . glsl-mode))
    :config (setq glsl-other-file-alist '(("\\.fs$" (".vs"))
                                          ("\\.vs$" (".fs")))))
#+END_SRC

** javascript

#+BEGIN_SRC emacs-lisp
  (req-package js2-mode
    :init (setq js2-highlight-level 3)
    :mode "\\.js$")
#+END_SRC

** Json

#+BEGIN_SRC emacs-lisp
  (req-package json-reformat :commands json-reformat-region)

  (req-package flymake-json :require flymake)

  (req-package json-mode
    :require flymake-json
    :mode ("\\.json$" . json-mode)
    :init (add-hook 'json-mode-hook (lambda () (flymake-json-load))))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (req-package markdown-mode
    :mode "\\.\\(md\\|markdown\\)\\'")
#+END_SRC

** Ruby

#+BEGIN_SRC emacs-lisp
  (req-package ruby-mode
    :mode (("Rakefile\\'" . ruby-mode)
           ("\\.rake$" . ruby-mode)
           ("\\.gemspec$" . ruby-mode)
           ("\\.rb$'" . ruby-mode)
           ("\\.ru$" . ruby-mode)
           ("Gemfile$" . ruby-mode)
           ("Guardfile$" . ruby-mode))
    :config
    (progn
      ;; We never want to edit Rubinius bytecode
      (add-to-list 'completion-ignored-extensions ".rbc")
      ))

  (req-package rake)
#+END_SRC

** QML

#+BEGIN_SRC emacs-lisp
  (req-package qml-mode
    :init (add-to-list 'auto-mode-alist '("\\.qml$" . qml-mode)))
#+END_SRC

** XML

#+BEGIN_SRC emacs-lisp
  (req-package nxml-mode
    :mode (("\\.pom$" . nxml-mode))
    :config
    (progn
      ;; Any file start with xml will be treat as nxml-mode
      (add-to-list 'magic-mode-alist '("<\\?xml" . nxml-mode))

      ;; Use nxml-mode instead of sgml, xml or html mode.
      (mapc
       (lambda (pair)
         (if (or (eq (cdr pair) 'xml-mode)
                 (eq (cdr pair) 'sgml-mode))
             (setcdr pair 'nxml-mode)))
       auto-mode-alist)
      ))
#+END_SRC

** SCSS

#+BEGIN_SRC emacs-lisp
  (req-package scss-mode
    :mode "\\.scss\\'"
    :config
    (progn
      ;; dont' build scss to css after save file
      (setq scss-compile-at-save nil)))
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
  (req-package css-mode :mode "\\.css\\'")
#+END_SRC

** Less

#+BEGIN_SRC emacs-lisp
  (req-package less-css-mode
    :init (add-to-list 'auto-mode-alist '("\\.less$" . less-css-mode))
    :mode "\\.less$")
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
  (req-package yaml-mode
    :mode "\\.yml$")
#+END_SRC

** Device Tree

#+BEGIN_SRC emacs-lisp
  (req-package dts-mode
    :mode (("\\.dts$" . dts-mode)
           ("\\.dtsi$" . dts-mode)))
#+END_SRC

** Swift

#+BEGIN_SRC emacs-lisp
  (req-package swift-mode
    :require flycheck
    :mode (("\\.dts$" . dts-mode)
           ("\\.dtsi$" . dts-mode))
    :init (add-to-list 'flycheck-checkers 'swift))
#+END_SRC

** BitBake

#+BEGIN_SRC emacs-lisp
  (req-package bitbake
    :mode "\\.bbclass$"
    :config
    (progn
      ;; For .inc file if locate under meta-*/ dir, make it use bitbake-mode
      (add-to-list 'magic-mode-alist
                   `(,(lambda ()
                        (and (string= (file-name-extension (or (buffer-file-name) "")) "inc")
                             (string-match "meta-" (buffer-file-name))))
                        . bitbake-mode))
      ))
#+END_SRC

* Web Development

** Use emmet-mode to add Zen Coding support

[[https://github.com/smihica/emmet-mode][emmet-mode]] is a fork of [[https://github.com/rooney/zencoding][zencoding-mode]] which add minor mode providing
support for Zen Coding by producing HTML from CSS-like selectors.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package emmet-mode
    :config
    (progn
      ;; Following mode support emmet-mode
      (add-hook 'html-mode-hook 'emmet-mode)
      (add-hook 'nxml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook  'emmet-mode)

      ;; Move cursor between quotes after expand
      (add-hook 'emmt-mode-hook
                '(lambda()
                   (setq emmet-move-cursor-between-quotes t)))

      ;; Make tab can also expand emmt instead of use yasnippet directly
      (define-key emmt-mode-keymap (kbd "TAB") 'emmt-expand-yas)
      (define-key emmt-mode-keymap (kbd "<tab>") 'emmt-expand-yas)))
#+END_SRC

* Version Control

** Git

*** Add suport for git configuration files


#+BEGIN_SRC emacs-lisp
  (req-package git-rebase-mode
    :mode ("/git-rebase-todo\\'" . git-rebase-mode))

  (req-package gitconfig-mode
    :mode (("/\\.?git/?config\\'" . gitconfig-mode)
           ("/\\.gitmodules\\'" . gitconfig-mode)
           ("/_gitconfig\\'" . gitconfig-mode))
    :config
    (add-hook 'gitconfig-mode-hook 'flyspell-mode))

  (req-package gitignore-mode
    :mode (("/\\.gitignore\\'" . gitignore-mode)
           ("/\\.git/info/exclude\\'" . gitignore-mode)
           ("/git/ignore\\'" . gitignore-mode)))
#+END_SRC

*** Major mode expand

#+BEGIN_SRC emacs-lisp
  (setq git-commit-mode-expand-alist
        '(("s" . git-commit-signoff)
          ("a" . git-commit-ack)
          ("t" . git-commit-test)
          ("R" . git-commit-review)
          ("c" . git-commit-cc)
          ("r" . git-commit-reported)))
#+END_SRC

*** Key Bindings

#+TBLNAME: magit-mode-keys
| Key | Command                | description            |
|-----+------------------------+------------------------|
| C-g | magit-mode-quit-window | Exit magit mode window |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
    (add-hook 'magit-mode-hook '(lambda()
              <<define-keys(map="magit-mode-map", keys=magit-mode-keys)>> ))
#+END_SRC

* Keybinding

** Generate keymap from org-mode table

org-mode  is really nice for literature programmering, I can use it to
generate keybing via table, just use following functions:

#+NAME: define-keys
#+BEGIN_SRC emacs-lisp :results output :tangle no :exports none :colnames nil
  (defvar dotemacs-init-done nil)

  (when (not dotemacs-init-done) (princ "(add-hook 'after-load-functions \n '(lambda (x)\n"))
  (mapcar (lambda (l)
            (let* ((key (nth 0 l))
                   (command (nth 1 l))
                   (def (format "define-key %s (kbd \"%s\")" map key)))
              ;; make sure key and command not nil
              (if (and key command)
                  (princ (format "(%s '%s)\n" def command)))))
          ;; remove all `hline' tag first line in list
          (cdr (remove 'hline keys)))
  (when (not dotemacs-init-done) (princ "))"))
#+END_SRC

** Spacemacs Map

** Normal State

#+TBLNAME: global-evil-normal
| Key     | Command             | description                          |
|---------+---------------------+--------------------------------------|
| C-x C-f | lusty-file-explorer | Use lusty-file-explorer to find-file |
| C-x C-q | read-only-mode      | toggle read-only-mode                |
| C-x C-s | save-buffer-always  | Always save buffer even not modified |
| C-x M-1 | deft-or-close       | Use deft open my note                |
| M-[     | winner-undo         | switch back to earlier window layout |
| M-]     | winner-redo         | restore resent window layout         |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
    <<define-keys(map="evil-normal-state-map", keys=global-evil-normal)>>
#+END_SRC

** Insert State

#+TBLNAME: global-evil-insert
| Key      | Command                             | description                          |
|----------+-------------------------------------+--------------------------------------|
| <delete> | hungry-delete-backward              | backward delete with hungru-mode     |
| C-;      | iedit-mode                          | Quicklly modify all same words       |
| C-d      | hungry-delete-forward               | forward delete with hungry-mode      |
| C-l      | hungry-delete-backward              | backward delete with hungru-mode     |
| C-n      | evil-next-line                      | next-line                            |
| C-o      | evil-execute-in-normal-state        | Temporary switch to Normal sate      |
| C-p      | evil-previous-line                  | previous-line                        |
| C-w      | backward-kill-word                  | Backward delete word                 |
| C-x C-f  | lusty-file-explorer                 | Use lusty-file-explorer to find-file |
| C-x C-n  | company-complete                    | Complete with company-mode           |
| C-x C-o  | ff-find-other-file                  | Find header/source in C/C++ file     |
| C-x C-q  | read-only-mode                      | toggle read-only-mode                |
| C-x C-s  | save-buffer-always                  | Always save buffer even not modified |
| C-x M-1  | deft-or-close                       | Use deft open my note                |
| C-x M-2  | multi-eshell                        | Show eshell window                   |
| C-x vl   | magit-log                           |                                      |
| C-x vp   | magit-push                          |                                      |
| C-x vs   | magit-status                        |                                      |
| M-<SPC>  | insert-U200B-char                   | Insert <U200B> character             |
| M-[      | winner-undo                         | switch back to earlier window layout |
| M-]      | winner-redo                         | restore resent window layout         |
| M-s      | helm-occur                          | Find in this file                    |
| M-s      | helm-occur                          | Search in current buffer             |
| s-<RET>  | insert-empty-line                   | Insert empty line after current line |
| s-<SPC>  | insert-U200B-char                   | Insert <U200B> character             |
| C-v      | rectangle-mark-mode/expand-region   |                                      |
| C-x C-i  | indent-region-or-buffer-and-cleanup | Intent region/buffer and clean up    |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
  <<define-keys(map="evil-insert-state-map", keys=global-evil-insert)>>
#+END_SRC

* End of configuration

At long last we need only call the following function to send
=req-package= on its merry way.

#+BEGIN_SRC emacs-lisp
  (req-package-finish)
#+END_SRC

Also setup =dotemacs-init-done= variable, this will help me to use
=C-c C-c= to evalute keybinding config without restart emacs.
#+BEGIN_SRC emacs-lisp
  (setq dotemacs-init-done t)
#+END_SRC
